<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elegant Text Editor - Client</title>
    <link rel="stylesheet" href="editor_styles.css">
</head>
<body>
    <div class="app">
        <div class="header">
            <div class="toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" onclick="newDocument()" title="New Document">üìÑ</button>
                    <button class="toolbar-btn" onclick="saveDocument()" title="Save" id="saveBtn">üíæ</button>
                    <button class="toolbar-btn" onclick="showServerSearch()" title="Search All Documents">üîé</button>
                </div>

                <div class="toolbar-group">
                    <input type="text" class="document-title" id="documentTitle" value="Untitled Document" onblur="updateTitle()" placeholder="Document Title">
                    <div class="status-indicator">
                        <div class="status-dot" id="statusDot"></div>
                        <span id="statusText">Saved</span>
                    </div>
                </div>
                
                <div class="toolbar-group">
                    <button class="toolbar-btn" onclick="document.execCommand('undo')" title="Undo">‚Ü∂</button>
                    <button class="toolbar-btn" onclick="document.execCommand('redo')" title="Redo">‚Ü∑</button>
                </div>
                
                <div class="toolbar-group">
                    <select class="toolbar-select" onchange="formatBlock(this.value)">
                        <option value="p">Paragraph</option>
                        <option value="h1">Heading 1</option>
                        <option value="h2">Heading 2</option>
                        <option value="h3">Heading 3</option>
                        <option value="blockquote">Quote</option>
                    </select>
                </div>

                <div class="toolbar-group">
                    <button class="toolbar-btn" onclick="formatText('bold')" title="Bold"><b>B</b></button>
                    <button class="toolbar-btn" onclick="formatText('italic')" title="Italic"><i>I</i></button>
                    <button class="toolbar-btn" onclick="formatText('underline')" title="Underline"><u>U</u></button>
                    <button class="toolbar-btn" onclick="formatText('strikeThrough')" title="Strike">SÃ∂</button>
                </div>

                <div class="toolbar-group">
                    <button class="toolbar-btn" onclick="formatText('insertUnorderedList')" title="Bullet List">‚Ä¢</button>
                    <button class="toolbar-btn" onclick="formatText('insertOrderedList')" title="Numbered List">1.</button>
                    <button class="toolbar-btn" onclick="formatText('indent')" title="Indent">‚Üí</button>
                    <button class="toolbar-btn" onclick="formatText('outdent')" title="Outdent">‚Üê</button>
                </div>

                <div class="toolbar-group">
                    <!--<button class="toolbar-btn" onclick="insertLink()" title="Link">üîó</button>-->
                    <button class="toolbar-btn" onclick="showSearch()" title="Search in Document">üîç</button>
                    <button class="toolbar-btn" onclick="clearSearchHighlight()" title="Clear Highlights">‚ú®</button>
                    <button class="toolbar-btn" onclick="exportDocument()" title="Export">üì§</button>
                    <button class="toolbar-btn" onclick="toggleFullscreen()" title="Focus Mode">‚ö°</button>
                </div>

                <div class="toolbar-group">
                    <div class="connection-status" id="connectionStatus">Connecting...</div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="sidebar-tabs">
                    <div class="sidebar-tab active" onclick="switchTab('outline')">Outline</div>
                    <div class="sidebar-tab" onclick="switchTab('documents')">Documents</div>
                    <div class="sidebar-tab" onclick="switchTab('stats')">Stats</div>
                </div>
                
                <div class="sidebar-content">
                    <div id="outlineTab" class="tab-content">
                        <h3>Document Outline</h3>
                        <div id="outline"></div>
                    </div>
                    
                    <div id="documentsTab" class="tab-content" style="display: none;">
                        <h3>Your Documents</h3>
                        <div id="documentsList">
                            <div class="no-documents">Loading documents...</div>
                        </div>
                    </div>
                    
                    <div id="statsTab" class="tab-content" style="display: none;">
                        <h3>Document Statistics</h3>
                        <div id="documentStats">
                            <div>Words: <span id="wordCount">0</span></div>
                            <div>Characters: <span id="charCount">0</span></div>
                            <div>Reading time: <span id="readTime">0 min</span></div>
                            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e2e8f0;">
                                <div>Server: <span id="serverStats">Loading...</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="editor-container">
                <div id="editor" class="editor" contenteditable="true" spellcheck="true">
                    <h1>Welcome to Your Cloud Text Editor</h1>
                    <p>Your documents are automatically saved to the server. Start writing and your work will be synced in real-time!</p>
                    
                    <h2>Features</h2>
                    <ul>
                        <li>Cloud storage with automatic saving</li>
                        <li>Multiple document management</li>
                        <li>Real-time document outline and navigation</li>
                        <li>Server-side document search</li>
                        <li>Export and sharing capabilities</li>
                        <li>Distraction-free focus mode</li>
                    </ul>

                    <h2>Getting Started</h2>
                    <p>Simply start typing to replace this content. Your document will be automatically saved to the server every few seconds.</p>
                    
                    <blockquote>
                        "The art of writing is the art of discovering what you believe." - Gustave Flaubert
                    </blockquote>

                    <p>Happy writing! ‚ú®</p>
                </div>
                
                <div class="status-bar">
                    <div class="word-count">
                        <span>Document: <span id="currentDocId">Not saved</span></span>
                        <span>Last saved: <span id="lastSaved">Never</span></span>
                    </div>
                    <div>
                        <span>Version: <span id="docVersion">0</span></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="floating-toolbar" id="floatingToolbar">
            <button onclick="formatText('bold')"><b>B</b></button>
            <button onclick="formatText('italic')"><i>I</i></button>
            <button onclick="formatText('underline')"><u>U</u></button>
            <!--<button onclick="insertLink()">üîó</button>-->
        </div>

        <!-- Modals and Overlays -->
        <div class="overlay" id="overlay" onclick="hideAllDialogs()"></div>
        
        <div class="search-box" id="searchBox">
            <h3>Search in Document</h3>
            <input type="text" class="search-input" id="searchInput" placeholder="Search document..." onkeyup="handleSearch(event)">
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="hideSearch()">Cancel</button>
                <button class="btn btn-primary" onclick="performSearch()">Search</button>
            </div>
        </div>

        <div class="modal" id="serverSearchBox">
            <h3>Search All Documents</h3>
            <input type="text" class="modal-input" id="serverSearchInput" placeholder="Search all documents..." onkeyup="handleServerSearch(event)">
            <div id="serverSearchResults" style="max-height: 300px; overflow-y: auto; margin: 16px 0;"></div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="hideServerSearch()">Cancel</button>
            </div>
        </div>

        <div class="modal" id="linkDialog">
            <!-- Link dialog will be dynamically created -->
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE_URL = 'https://168.231.102.44:5000/editor/api';
        
        // Global state
        let editor = document.getElementById('editor');
        let currentDocument = null;
        let isFullscreen = false;
        let searchResults = [];
        let currentSearchIndex = 0;
        let saveTimeout = null;
        let isConnected = false;
        let documents = [];
        
        

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeEditor();
        });

        async function initializeEditor() {
            updateConnectionStatus('connecting');
            setupEventListeners();
            
            try {
                await checkServerConnection();
                await loadDocuments();
                await createNewDocument();
                updateConnectionStatus('connected');
            } catch (error) {
                console.error('Failed to initialize editor:', error);
                updateConnectionStatus('disconnected');
                // Continue with offline mode
                updateStats();
                updateOutline();
            }
        }

        function setupEventListeners() {
            editor.addEventListener('input', function() {
                updateStats();
                updateOutline();
                scheduleAutoSave();
            });

            // Selection change for floating toolbar
            document.addEventListener('selectionchange', function() {
                const selection = window.getSelection();
                if (selection.rangeCount > 0 && !selection.isCollapsed && 
                    editor.contains(selection.anchorNode)) {
                    showFloatingToolbar(selection);
                } else {
                    hideFloatingToolbar();
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.target.tagName === 'INPUT' && e.target.type === 'text') {
                    return;
                }
                
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'b':
                            e.preventDefault();
                            formatText('bold');
                            break;
                        case 'i':
                            e.preventDefault();
                            formatText('italic');
                            break;
                        case 'u':
                            e.preventDefault();
                            formatText('underline');
                            break;
                        case 'k':
                            e.preventDefault();
                            insertLink();
                            break;
                        case 'f':
                            e.preventDefault();
                            showSearch();
                            break;
                        case 's':
                            e.preventDefault();
                            saveDocument();
                            break;
                        case 'n':
                            e.preventDefault();
                            newDocument();
                            break;
                    }
                }
                if (e.key === 'F11') {
                    e.preventDefault();
                    toggleFullscreen();
                }
                if (e.key === 'Escape') {
                    hideAllDialogs();
                }
            });
        }

        // Server communication functions
        async function makeRequest(url, options = {}) {
            try {
                const response = await fetch(url, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('API request failed:', error);
                updateConnectionStatus('disconnected');
                throw error;
            }
        }

        async function checkServerConnection() {
            try {
                const response = await makeRequest(API_BASE_URL);
                isConnected = true;
                return response;
            } catch (error) {
                isConnected = false;
                throw error;
            }
        }

        async function createNewDocument() {
            try {
                const response = await makeRequest(`${API_BASE_URL}/documents`, {
                    method: 'POST',
                    body: JSON.stringify({
                        title: 'Untitled Document'
                    })
                });
                
                if (response.success) {
                    currentDocument = response.document;
                    updateDocumentUI();
                    await loadDocuments();
                }
            } catch (error) {
                console.error('Failed to create document:', error);
                showStatus('Failed to create document', 'error');
            }
        }

        async function saveDocument() {
            if (!currentDocument || !isConnected) {
                showStatus('Cannot save - not connected to server', 'error');
                return;
            }

            try {
                showStatus('Saving...', 'saving');
                
                const content = {
                    title: document.getElementById('documentTitle').value,
                    text: editor.innerHTML,
                    plain_text: editor.innerText
                };

                const response = await makeRequest(`${API_BASE_URL}/documents/${currentDocument.id}`, {
                    method: 'PUT',
                    body: JSON.stringify(content)
                });

                if (response.success) {
                    currentDocument = response.document;
                    updateDocumentUI();
                    showStatus('Saved', 'saved');
                    await loadDocuments();
                } else {
                    showStatus('Failed to save', 'error');
                }
            } catch (error) {
                console.error('Failed to save document:', error);
                showStatus('Failed to save', 'error');
            }
        }

        async function loadDocument(docId) {
            try {
                showStatus('Loading...', 'saving');
                
                const response = await makeRequest(`${API_BASE_URL}/documents/${docId}`);
                
                if (response.success) {
                    currentDocument = response.document;
                    editor.innerHTML = currentDocument.text;
                    document.getElementById('documentTitle').value = currentDocument.title;
                    updateDocumentUI();
                    updateStats();
                    updateOutline();
                    showStatus('Loaded', 'saved');
                    
                    // Update active document in sidebar
                    updateDocumentsList();
                } else {
                    showStatus('Failed to load document', 'error');
                }
            } catch (error) {
                console.error('Failed to load document:', error);
                showStatus('Failed to load document', 'error');
            }
        }

        async function loadDocuments() {
            try {
                const response = await makeRequest(`${API_BASE_URL}/documents`);
                
                if (response.success) {
                    documents = response.documents;
                    updateDocumentsList();
                }
            } catch (error) {
                console.error('Failed to load documents:', error);
            }
        }

        async function deleteDocument(docId) {
            if (!confirm('Are you sure you want to delete this document?')) {
                return;
            }

            try {
                const response = await makeRequest(`${API_BASE_URL}/documents/${docId}`, {
                    method: 'DELETE'
                });

                if (response.success) {
                    if (currentDocument && currentDocument.id === docId) {
                        await createNewDocument();
                    }
                    await loadDocuments();
                    showStatus('Document deleted', 'saved');
                }
            } catch (error) {
                console.error('Failed to delete document:', error);
                showStatus('Failed to delete document', 'error');
            }
        }

        async function searchDocuments(query) {
            try {
                const response = await makeRequest(`${API_BASE_URL}/search?q=${encodeURIComponent(query)}`);
                return response.success ? response.results : [];
            } catch (error) {
                console.error('Failed to search documents:', error);
                return [];
            }
        }

        async function loadServerStats() {
            try {
                const response = await makeRequest(`${API_BASE_URL}/stats`);
                if (response.success) {
                    document.getElementById('serverStats').innerHTML = `${response.stats.total_documents} docs, ${response.stats.total_words} words
                    `;
                }
            } catch (error) {
                document.getElementById('serverStats').textContent = 'Offline';
            }
        }

        // UI update functions
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const statusClass = status === 'connected' ? 'connected' : 'disconnected';
            
            statusElement.className = `connection-status ${statusClass}`;
            statusElement.textContent = status === 'connected' ? 'Connected' : 
                                      status === 'connecting' ? 'Connecting...' : 'Offline';
        }

        function updateDocumentUI() {
            if (currentDocument) {
                document.getElementById('currentDocId').textContent = currentDocument.id.substring(0, 8);
                document.getElementById('lastSaved').textContent = new Date(currentDocument.updated_at).toLocaleTimeString();
                document.getElementById('docVersion').textContent = currentDocument.update;
                document.getElementById('documentTitle').value = currentDocument.title;
            }
        }

        function updateDocumentsList() {
            const list = document.getElementById('documentsList');
            
            if (documents.length === 0) {
                list.innerHTML = '<div class="no-documents">No documents found</div>';
                return;
            }

            list.innerHTML = '';
            documents.forEach(doc => {
                const item = document.createElement('div');
                item.className = `document-item ${currentDocument && currentDocument.id === doc.id ? 'active' : ''}`;
                item.innerHTML = `
                    <h4>${doc.title}</h4>
                    <p>${doc.word_count} words</p>
                    <div class="meta">
                        Modified: ${new Date(doc.updated_at).toLocaleDateString()}
                        <button onclick="deleteDocument('${doc.id}')" style="float: right; background: none; border: none; color: #ef4444; cursor: pointer; font-size: 12px;">Delete</button>
                    </div>
                `;
                item.onclick = (e) => {
                    if (e.target.tagName !== 'BUTTON') {
                        loadDocument(doc.id);
                    }
                };
                list.appendChild(item);
            });
        }

        function scheduleAutoSave() {
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            saveTimeout = setTimeout(() => {
                if (currentDocument && isConnected) {
                    saveDocument();
                }
            }, 3000); // Auto-save after 3 seconds of inactivity
        }

        function showStatus(message, type = 'saved') {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            statusDot.className = `status-dot ${type}`;
            statusText.textContent = message;
            
            if (type === 'saved') {
                setTimeout(() => {
                    statusDot.className = 'status-dot';
                    statusText.textContent = 'Saved';
                }, 2000);
            }
        }

        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.sidebar-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(tabName + 'Tab').style.display = 'block';
            
            // Load content based on tab
            if (tabName === 'documents') {
                loadDocuments();
            } else if (tabName === 'stats') {
                loadServerStats();
            }
        }

        // Document management functions
        async function newDocument() {
            await createNewDocument();
        }

        function updateTitle() {
            if (currentDocument) {
                scheduleAutoSave();
            }
        }

        // Text formatting functions (same as before but with error handling)
        function hideAllDialogs() {
            hideSearch();
            hideLinkDialog();
            hideServerSearch();
        }

        function formatText(command) {
            try {
                document.execCommand(command, false, null);
                updateToolbarState();
            } catch (error) {
                console.warn('execCommand failed:', error);
                fallbackFormatText(command);
            }
        }

        function fallbackFormatText(command) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            
            const range = selection.getRangeAt(0);
            const selectedText = range.toString();
            
            if (!selectedText) return;
            
            let replacement;
            switch(command) {
                case 'bold':
                    replacement = `<strong>${selectedText}</strong>`;
                    break;
                case 'italic':
                    replacement = `<em>${selectedText}</em>`;
                    break;
                case 'underline':
                    replacement = `<u>${selectedText}</u>`;
                    break;
                default:
                    return;
            }
            
            try {
                range.deleteContents();
                const fragment = range.createContextualFragment(replacement);
                range.insertNode(fragment);
            } catch (error) {
                console.warn('Fallback formatting failed:', error);
            }
        }

        function formatBlock(tag) {
            document.execCommand('formatBlock', false, tag);
            updateOutline();
            scheduleAutoSave();
        }

        function updateToolbarState() {
            try {
                const toolbarBtns = document.querySelectorAll('.toolbar-btn');
                const commands = ['bold', 'italic', 'underline', 'strikeThrough'];
                
                toolbarBtns.forEach((btn, index) => {
                    if (index >= 5 && index <= 8) { // Format buttons (adjusted for new layout)
                        const command = commands[index - 5];
                        try {
                            if (document.queryCommandState && document.queryCommandState(command)) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        } catch (error) {
                            btn.classList.remove('active');
                        }
                    }
                });
            } catch (error) {
                console.warn('Failed to update toolbar state:', error);
            }
        }

        function updateStats() {
            const text = editor.innerText;
            const words = text.trim().split(/\s+/).filter(word => word.length > 0);
            const wordCount = words.length;
            const charCount = text.length;
            const readTime = Math.ceil(wordCount / 200);

            document.getElementById('wordCount').textContent = wordCount;
            document.getElementById('charCount').textContent = charCount;
            document.getElementById('readTime').textContent = readTime + ' min';
        }

        function updateOutline() {
            const headings = editor.querySelectorAll('h1, h2, h3');
            const outline = document.getElementById('outline');
            outline.innerHTML = '';

            if (headings.length === 0) {
                outline.innerHTML = '<div class="no-documents">No headings found</div>';
                return;
            }

            headings.forEach((heading, index) => {
                const item = document.createElement('div');
                item.className = `outline-item ${heading.tagName.toLowerCase()}`;
                item.textContent = heading.textContent;
                item.onclick = () => heading.scrollIntoView({ behavior: 'smooth' });
                outline.appendChild(item);
            });
        }

        // Search functions
        function showSearch() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('searchBox').style.display = 'block';
            document.getElementById('searchInput').focus();
        }

        function hideSearch() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('searchBox').style.display = 'none';
        }

        function handleSearch(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        }

        function performSearch() {
            const query = document.getElementById('searchInput').value;
            if (!query) return;

            clearSearchHighlight();
            
            const text = editor.innerHTML;
            const regex = new RegExp(query, 'gi');
            const highlighted = text.replace(regex, `<mark class="search-highlight" style="background: yellow; padding: 2px 4px; border-radius: 3px;">$&</mark>`);
            
            editor.innerHTML = highlighted;
            hideSearch();
        }

        function clearSearchHighlight() {
            const highlights = editor.querySelectorAll('.search-highlight');
            highlights.forEach(highlight => {
                const parent = highlight.parentNode;
                parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
                parent.normalize();
            });
        }

        // Server search functions
        function showServerSearch() {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById('serverSearchBox').style.display = 'block';
            document.getElementById('serverSearchInput').focus();
        }

        function hideServerSearch() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('serverSearchBox').style.display = 'none';
        }

        async function handleServerSearch(event) {
            const query = event.target.value;
            if (query.length < 2) {
                document.getElementById('serverSearchResults').innerHTML = '';
                return;
            }
            
            if (event.key === 'Enter' || query.length >= 2) {
                await performServerSearch(query);
            }
        }

        async function performServerSearch(query) {
            try {
                const results = await searchDocuments(query);
                const resultsContainer = document.getElementById('serverSearchResults');
                
                if (results.length === 0) {
                    resultsContainer.innerHTML = '<div class="no-documents">No results found</div>';
                    return;
                }
                
                resultsContainer.innerHTML = '';
                results.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'document-item';
                    item.innerHTML = `
                        <h4>${result.title}</h4>
                        <p>${result.snippet}</p>
                        <div class="meta">Modified: ${new Date(result.updated_at).toLocaleDateString()}</div>
                    `;
                    item.onclick = () => {
                        loadDocument(result.id);
                        hideServerSearch();
                    };
                    resultsContainer.appendChild(item);
                });
            } catch (error) {
                document.getElementById('serverSearchResults').innerHTML = '<div class="no-documents">Search failed</div>';
            }
        }

        // Link functions
        function insertLink() {
            const selection = window.getSelection();
            let selectedText = '';
            
            if (selection.rangeCount > 0 && !selection.isCollapsed) {
                selectedText = selection.toString();
            }
            
            showLinkDialog(selectedText);
        }

        function showLinkDialog(selectedText = '') {
            const overlay = document.getElementById('overlay');
            const linkDialog = document.getElementById('linkDialog');
            
            linkDialog.innerHTML = `
                <h3>Insert Link</h3>
                <input type="text" id="linkText" class="modal-input" placeholder="Link text" value="${selectedText}">
                <input type="text" id="linkUrl" class="modal-input" placeholder="https://example.com">
                <div class="modal-buttons">
                    <button class="btn btn-secondary" onclick="hideLinkDialog()">Cancel</button>
                    <button class="btn btn-primary" onclick="createLink()">Insert Link</button>
                </div>
            `;
            
            linkDialog.style.display = 'block';
            overlay.style.display = 'block';
            document.getElementById('linkText').focus();
        }

        function hideLinkDialog() {
            const linkDialog = document.getElementById('linkDialog');
            const overlay = document.getElementById('overlay');
            
            if (linkDialog) {
                linkDialog.style.display = 'none';
            }
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        function createLink() {
            const linkText = document.getElementById('linkText').value.trim();
            const linkUrl = document.getElementById('linkUrl').value.trim();
            
            if (!linkText || !linkUrl) {
                alert('Please fill in both fields');
                return;
            }
            
            let validUrl = linkUrl;
            if (!linkUrl.startsWith('http://') && !linkUrl.startsWith('https://')) {
                validUrl = 'https://' + linkUrl;
            }
            
            try {
                new URL(validUrl);
            } catch (error) {
                alert('Please enter a valid URL');
                return;
            }
            
            const link = `<a href="${validUrl}" target="_blank" rel="noopener noreferrer" style="color: #3182ce; text-decoration: underline; cursor: pointer;" onclick="window.open('${validUrl}', '_blank')">${linkText}</a>`;
            
            try {
                if (document.execCommand) {
                    document.execCommand('insertHTML', false, link);
                } else {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const fragment = range.createContextualFragment(link);
                        range.deleteContents();
                        range.insertNode(fragment);
                    }
                }
                scheduleAutoSave();
            } catch (error) {
                console.warn('Failed to insert link:', error);
            }
            
            hideLinkDialog();
        }

        // Floating toolbar functions
        function showFloatingToolbar(selection) {
            const toolbar = document.getElementById('floatingToolbar');
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            
            toolbar.style.display = 'block';
            toolbar.style.left = (rect.left + rect.width / 2 - toolbar.offsetWidth / 2) + 'px';
            toolbar.style.top = (rect.top - toolbar.offsetHeight - 10) + 'px';
        }

        function hideFloatingToolbar() {
            document.getElementById('floatingToolbar').style.display = 'none';
        }

        // Export and fullscreen functions
        function exportDocument() {
            if (!currentDocument) {
                alert('No document to export');
                return;
            }

            const content = editor.innerHTML;
            const blob = new Blob([`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${escapeHtml(currentDocument.title)}</title>
                    <style>
                        body { font-family: Georgia, serif; max-width: 800px; margin: 0 auto; padding: 40px; line-height: 1.6; }
                        h1 { font-size: 32px; margin: 24px 0 16px 0; }
                        h2 { font-size: 24px; margin: 20px 0 12px 0; }
                        h3 { font-size: 20px; margin: 16px 0 8px 0; }
                        blockquote { border-left: 4px solid #3182ce; padding: 16px; margin: 16px 0; background: #f7fafc; }
                    </style`+`>
                </head`+`>
                <body`+`>`+`${content}`+`</body`+`>
                </html`+`>
                `],
                { type: 'text/html' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentDocument.title}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function toggleFullscreen() {
            const sidebar = document.querySelector('.sidebar');
            const header = document.querySelector('.header');
            const focusBtn = document.querySelector('[onclick="toggleFullscreen()"]');
            
            if (!isFullscreen) {
                sidebar.style.display = 'none';
                header.style.display = 'none';
                document.body.style.background = '#fff';
                editor.style.padding = '80px';
                focusBtn.textContent = '‚Ü©Ô∏è';
                focusBtn.title = 'Exit Focus Mode';
                isFullscreen = true;
                
                const exitBtn = document.createElement('button');
                exitBtn.id = 'exitFocusBtn';
                exitBtn.innerHTML = '‚Ü©Ô∏è Exit Focus Mode';
                exitBtn.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(0,0,0,0.7);
                    color: white;
                    border: none;
                    padding: 12px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    z-index: 1000;
                    transition: all 0.2s;
                `;
                exitBtn.onmouseover = () => exitBtn.style.background = 'rgba(0,0,0,0.9)';
                exitBtn.onmouseout = () => exitBtn.style.background = 'rgba(0,0,0,0.7)';
                exitBtn.onclick = toggleFullscreen;
                document.body.appendChild(exitBtn);
                
            } else {
                sidebar.style.display = 'block';
                header.style.display = 'block';
                document.body.style.background = '#fafafa';
                editor.style.padding = '40px';
                focusBtn.textContent = '‚ö°';
                focusBtn.title = 'Focus Mode';
                isFullscreen = false;
                
                const exitBtn = document.getElementById('exitFocusBtn');
                if (exitBtn) {
                    exitBtn.remove();
                }
            }
        }

        // Utility functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize periodic tasks
        setInterval(() => {
            if (isConnected) {
                loadServerStats();
            }
        }, 30000); // Update server stats every 30 seconds

        // Handle page visibility for auto-save
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden' && currentDocument && isConnected) {
                saveDocument();
            }
        });

        // Handle beforeunload to save document
        window.addEventListener('beforeunload', (e) => {
            if (currentDocument && isConnected && saveTimeout) {
                e.preventDefault();
                saveDocument();
                e.returnValue = '';
            }
        });
    </script>
</body>
</html>